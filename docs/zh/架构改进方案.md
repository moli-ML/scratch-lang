# ScratchLang 编译器架构改进方案

## 一、当前架构评估

### 1.1 现状分析

**当前架构：正则表达式 + 状态机**

```
用户代码 → 预处理 → 正则匹配 → 积木生成 → SB3打包
```

**优点：**
- ✅ 实现简单，代码量小（~2000行）
- ✅ 对简单语法支持良好
- ✅ 易于维护和调试
- ✅ 性能足够（小型项目）
- ✅ 已经支持大部分Scratch功能

**缺点：**
- ❌ 表达式解析能力弱（无法处理复杂嵌套）
- ❌ 运算符优先级处理不正确
- ❌ 对缩进混用敏感
- ❌ 扩展性受限

### 1.2 问题严重程度评估

| 问题 | 严重程度 | 影响范围 | 用户痛点 |
|------|---------|---------|---------|
| 复杂表达式嵌套 | 🟡 中 | 高级用户 | 无法写 `(a+b)*(c+d)` |
| 运算符优先级 | 🟡 中 | 中级用户 | `a 或 b 且 c` 结果错误 |
| 缩进混用问题 | 🟢 低 | 少数用户 | 复制粘贴代码失败 |
| 正则性能问题 | 🟢 低 | 大型项目 | 编译速度慢 |

**结论：当前架构对于80%的用户场景是足够的，但限制了高级用户的使用。**

---

## 二、改进方案对比

### 2.1 方案A：渐进式改进（推荐）

**核心思路：保留现有架构，针对性增强表达式解析**

#### 实施步骤：

**阶段1：表达式解析器（优先级最高）**
- 实现简单的递归下降表达式解析器
- 支持运算符优先级：`()` > `*/%` > `+-` > `><>=<=` > `且` > `或`
- 支持嵌套括号：`(1+2)*(3+4)`
- 保留现有正则匹配其他语法

**工作量：** 2-3天
**风险：** 低
**收益：** 解决70%的表达式问题

**阶段2：缩进规范化（优先级中）**
- 预处理阶段统一Tab转空格
- 添加缩进检查和警告
- 支持混合缩进自动修复

**工作量：** 1天
**风险：** 低
**收益：** 提升代码健壮性

**阶段3：错误提示优化（优先级中）**
- 添加行号追踪
- 详细的错误信息
- 语法建议

**工作量：** 1-2天
**风险：** 低
**收益：** 提升用户体验

#### 优点：
- ✅ 风险可控，可逐步实施
- ✅ 不破坏现有功能
- ✅ 快速见效
- ✅ 代码量增加有限（+500行）

#### 缺点：
- ❌ 仍然是"补丁式"改进
- ❌ 无法支持极端复杂的语法

---

### 2.2 方案B：引入Lark解析器

**核心思路：使用Lark定义完整语法，生成AST**

#### 实施步骤：

1. 编写EBNF语法文件（.lark）
2. 使用Lark生成解析树
3. 遍历AST生成Scratch积木
4. 保留现有的builder.py和assets.py

**工作量：** 1-2周
**风险：** 中
**收益：** 完整的语法支持

#### 优点：
- ✅ 语法定义清晰
- ✅ 自动处理优先级
- ✅ 易于扩展新语法
- ✅ 错误提示友好

#### 缺点：
- ❌ 需要学习Lark
- ❌ 增加依赖
- ❌ 需要重写大部分parser.py
- ❌ 可能引入新bug

---

### 2.3 方案C：完全重构（不推荐）

**核心思路：手写递归下降解析器，构建完整AST**

**工作量：** 3-4周
**风险：** 高
**收益：** 完全控制，无依赖

#### 优点：
- ✅ 无外部依赖
- ✅ 完全控制
- ✅ 性能最优

#### 缺点：
- ❌ 工作量巨大
- ❌ 容易引入bug
- ❌ 维护成本高
- ❌ 性价比低

---

## 三、推荐方案：渐进式改进

### 3.1 为什么选择方案A？

1. **风险最低**：不破坏现有功能
2. **快速见效**：2-3天即可解决主要问题
3. **成本可控**：代码量增加有限
4. **用户友好**：不需要重新学习语法

### 3.2 具体实施计划

#### 第一步：实现表达式解析器（核心）

**新增文件：** `compiler/expression_parser.py`

```python
class ExpressionParser:
    """递归下降表达式解析器"""

    def parse(self, text: str) -> dict:
        """解析表达式，返回Scratch积木结构"""
        # 支持：
        # - 算术运算：+ - * / %
        # - 比较运算：> < >= <= = ≠
        # - 逻辑运算：且 或 非
        # - 括号嵌套：(...)
        # - 函数调用：四舍五入(...), abs(...)
        pass
```

**修改文件：** `compiler/parser.py`

```python
def _parse_value(self, text):
    # 检测是否为复杂表达式
    if self._is_complex_expression(text):
        # 使用新的表达式解析器
        return self.expr_parser.parse(text)
    else:
        # 使用现有的简单解析
        return self._parse_simple_value(text)
```

**测试用例：**
```python
# test_expression_parser.py
def test_arithmetic():
    assert parse("(1+2)*3") == 9
    assert parse("10/2+3") == 8

def test_logic():
    assert parse("1>0 且 2>1") == True
    assert parse("1>0 或 2<1") == True

def test_nested():
    assert parse("((1+2)*3+4)/5") == 2
```

#### 第二步：缩进规范化

**修改文件：** `compiler/parser.py`

```python
def _normalize_indentation(self, code: str) -> str:
    """统一缩进格式"""
    lines = code.split('\n')
    normalized = []

    for line in lines:
        # Tab转4个空格
        line = line.replace('\t', '    ')
        # 检测混合缩进
        if self._has_mixed_indent(line):
            self._warn_mixed_indent(line_num)
        normalized.append(line)

    return '\n'.join(normalized)
```

#### 第三步：错误提示优化

**新增文件：** `compiler/error_reporter.py`

```python
class ErrorReporter:
    """友好的错误提示"""

    def report_syntax_error(self, line_num, line_text, error_msg):
        """
        输出格式：

        错误：第 10 行
        > 如果 a 或 b 且 c 那么
                    ^^
        运算符优先级错误
        建议：使用括号明确优先级
        > 如果 (a 或 b) 且 c 那么
        """
        pass
```

---

## 四、实施时间表

### 阶段1：表达式解析器（Week 1）
- Day 1-2: 实现基础表达式解析器
- Day 3: 集成到现有parser
- Day 4: 测试和修复bug
- Day 5: 文档更新

### 阶段2：缩进规范化（Week 2）
- Day 1: 实现缩进规范化
- Day 2: 测试和优化
- Day 3: 添加警告提示

### 阶段3：错误提示优化（Week 3）
- Day 1-2: 实现错误报告器
- Day 3: 集成到编译流程
- Day 4-5: 完善错误信息库

---

## 五、风险评估

### 5.1 技术风险

| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|---------|
| 表达式解析器bug | 中 | 中 | 充分测试，保留旧逻辑作为fallback |
| 性能下降 | 低 | 低 | 只对复杂表达式使用新解析器 |
| 兼容性问题 | 低 | 高 | 保持向后兼容，添加版本检测 |

### 5.2 用户影响

- **正面影响：** 支持更复杂的表达式，错误提示更友好
- **负面影响：** 几乎没有（向后兼容）
- **迁移成本：** 零（自动兼容旧代码）

---

## 六、长期规划

### 6.1 如果未来需要更强大的功能

**触发条件：**
- 用户需要自定义语法
- 需要支持宏/元编程
- 需要类型系统
- 需要编译优化

**那时再考虑：**
- 迁移到Lark或手写完整解析器
- 构建完整的AST和IR
- 实现编译优化pass

### 6.2 保持简单原则

> "过早优化是万恶之源" - Donald Knuth

**建议：**
- 只在用户真正需要时才添加复杂功能
- 保持核心简单，高级功能可选
- 优先考虑用户体验而非技术完美

---

## 七、总结

### 推荐方案：渐进式改进（方案A）

**理由：**
1. ✅ 解决80%的实际问题
2. ✅ 风险可控，快速见效
3. ✅ 不破坏现有功能
4. ✅ 代码量增加有限
5. ✅ 为未来升级留有余地

**不推荐：**
- ❌ 完全重构（方案C）：性价比低，风险高
- ⚠️ 引入Lark（方案B）：可作为长期目标，但当前不是最优选择

### 下一步行动

1. **立即开始：** 实现表达式解析器（优先级最高）
2. **同步进行：** 编写测试用例
3. **持续改进：** 根据用户反馈迭代

### 成功标准

- ✅ 支持 `(1+2)*(3+4)` 类型的表达式
- ✅ 正确处理 `a 或 b 且 c` 的优先级
- ✅ 所有现有测试用例通过
- ✅ 新增50+个表达式测试用例
- ✅ 编译速度不下降
