# 表达式解析器实施方案（防屎山版）

## 一、架构设计原则

### 核心思想：分层解耦

```
用户代码 → Lexer(分词) → ExpressionParser(解析) → ASTNode(树) → ScratchBuilder(JSON) → SB3
```

**关键点：每一层都是独立的黑盒，可单独测试。**

---

## 二、具体实现架构

### 2.1 第一层：Lexer（分词器）

**文件：** `compiler/lexer.py`

**职责：** 将字符串转换为Token列表

```python
from enum import Enum
from dataclasses import dataclass

class TokenType(Enum):
    NUMBER = "NUMBER"
    STRING = "STRING"
    VARIABLE = "VARIABLE"  # ~变量名
    OPERATOR = "OPERATOR"  # + - * / % > < >= <= = ≠
    LOGIC = "LOGIC"        # 且 或 非
    LPAREN = "LPAREN"      # (
    RPAREN = "RPAREN"      # )
    FUNCTION = "FUNCTION"  # 四舍五入, abs, sqrt等
    EOF = "EOF"

@dataclass
class Token:
    type: TokenType
    value: any
    pos: int  # 位置，用于错误提示

class Lexer:
    """分词器：字符串 → Token列表"""

    def __init__(self, text: str):
        self.text = text
        self.pos = 0

    def tokenize(self) -> list[Token]:
        """
        输入: "1 + (a * 2)"
        输出: [
            Token(NUMBER, 1, 0),
            Token(OPERATOR, '+', 2),
            Token(LPAREN, '(', 4),
            Token(VARIABLE, 'a', 5),
            Token(OPERATOR, '*', 7),
            Token(NUMBER, 2, 9),
            Token(RPAREN, ')', 10),
            Token(EOF, None, 11)
        ]
        """
        tokens = []
        while self.pos < len(self.text):
            # 跳过空格
            if self.text[self.pos].isspace():
                self.pos += 1
                continue

            # 数字
            if self.text[self.pos].isdigit():
                tokens.append(self._read_number())
            # 字符串
            elif self.text[self.pos] in '"\'':
                tokens.append(self._read_string())
            # 变量引用
            elif self.text[self.pos] == '~':
                tokens.append(self._read_variable())
            # 运算符
            elif self.text[self.pos] in '+-*/%><>=≠':
                tokens.append(self._read_operator())
            # 括号
            elif self.text[self.pos] == '(':
                tokens.append(Token(TokenType.LPAREN, '(', self.pos))
                self.pos += 1
            elif self.text[self.pos] == ')':
                tokens.append(Token(TokenType.RPAREN, ')', self.pos))
                self.pos += 1
            # 逻辑运算符或函数
            else:
                tokens.append(self._read_word())

        tokens.append(Token(TokenType.EOF, None, self.pos))
        return tokens
```

---

### 2.2 第二层：AST Node（抽象语法树节点）

**文件：** `compiler/ast_nodes.py`

**职责：** 定义表达式的树结构

```python
from dataclasses import dataclass
from typing import Union

@dataclass
class ASTNode:
    """AST基类"""
    pass

@dataclass
class NumberNode(ASTNode):
    """数字节点"""
    value: float

@dataclass
class StringNode(ASTNode):
    """字符串节点"""
    value: str

@dataclass
class VariableNode(ASTNode):
    """变量节点"""
    name: str

@dataclass
class BinOpNode(ASTNode):
    """二元运算节点"""
    left: ASTNode
    op: str  # '+', '-', '*', '/', '>', '<', '且', '或'
    right: ASTNode

@dataclass
class UnaryOpNode(ASTNode):
    """一元运算节点"""
    op: str  # '非', '-'
    operand: ASTNode

@dataclass
class FunctionNode(ASTNode):
    """函数调用节点"""
    name: str  # '四舍五入', 'abs', 'sqrt'
    args: list[ASTNode]

# 示例：表达式 "(1 + 2) * 3" 的AST
# BinOpNode(
#     left=BinOpNode(
#         left=NumberNode(1),
#         op='+',
#         right=NumberNode(2)
#     ),
#     op='*',
#     right=NumberNode(3)
# )
```

---

### 2.3 第三层：ExpressionParser（表达式解析器）

**文件：** `compiler/expression_parser.py`

**职责：** Token列表 → AST

```python
class ExpressionParser:
    """递归下降解析器：Token列表 → AST"""

    def __init__(self, tokens: list[Token]):
        self.tokens = tokens
        self.pos = 0

    def parse(self) -> ASTNode:
        """解析表达式"""
        return self._parse_or()

    # 运算符优先级（从低到高）：
    # 或 → 且 → 比较(><>=<=) → 加减 → 乘除 → 一元(非,-) → 括号/原子

    def _parse_or(self) -> ASTNode:
        """解析 或 运算"""
        left = self._parse_and()
        while self._match_logic('或'):
            op = self._consume().value
            right = self._parse_and()
            left = BinOpNode(left, op, right)
        return left

    def _parse_and(self) -> ASTNode:
        """解析 且 运算"""
        left = self._parse_comparison()
        while self._match_logic('且'):
            op = self._consume().value
            right = self._parse_comparison()
            left = BinOpNode(left, op, right)
        return left

    def _parse_comparison(self) -> ASTNode:
        """解析比较运算"""
        left = self._parse_add_sub()
        while self._match_operator(['>', '<', '>=', '<=', '=', '≠']):
            op = self._consume().value
            right = self._parse_add_sub()
            left = BinOpNode(left, op, right)
        return left

    def _parse_add_sub(self) -> ASTNode:
        """解析加减运算"""
        left = self._parse_mul_div()
        while self._match_operator(['+', '-']):
            op = self._consume().value
            right = self._parse_mul_div()
            left = BinOpNode(left, op, right)
        return left

    def _parse_mul_div(self) -> ASTNode:
        """解析乘除运算"""
        left = self._parse_unary()
        while self._match_operator(['*', '/', '%']):
            op = self._consume().value
            right = self._parse_unary()
            left = BinOpNode(left, op, right)
        return left

    def _parse_unary(self) -> ASTNode:
        """解析一元运算"""
        if self._match_logic('非'):
            op = self._consume().value
            operand = self._parse_unary()
            return UnaryOpNode(op, operand)
        if self._match_operator(['-']):
            op = self._consume().value
            operand = self._parse_unary()
            return UnaryOpNode(op, operand)
        return self._parse_primary()

    def _parse_primary(self) -> ASTNode:
        """解析原子表达式"""
        # 括号
        if self._match(TokenType.LPAREN):
            self._consume()  # 消耗 (
            expr = self._parse_or()
            self._expect(TokenType.RPAREN)  # 期望 )
            return expr

        # 函数调用
        if self._match(TokenType.FUNCTION):
            return self._parse_function()

        # 数字
        if self._match(TokenType.NUMBER):
            return NumberNode(self._consume().value)

        # 字符串
        if self._match(TokenType.STRING):
            return StringNode(self._consume().value)

        # 变量
        if self._match(TokenType.VARIABLE):
            return VariableNode(self._consume().value)

        raise ParseError(f"意外的token: {self._current()}")

    def _parse_function(self) -> ASTNode:
        """解析函数调用"""
        name = self._consume().value
        self._expect(TokenType.LPAREN)
        args = []
        if not self._match(TokenType.RPAREN):
            args.append(self._parse_or())
            while self._match_operator([',']):
                self._consume()
                args.append(self._parse_or())
        self._expect(TokenType.RPAREN)
        return FunctionNode(name, args)
```

---

### 2.4 第四层：ASTToScratch（AST → Scratch JSON）

**文件：** `compiler/ast_to_scratch.py`

**职责：** AST → Scratch积木JSON

```python
class ASTToScratch:
    """将AST转换为Scratch积木JSON"""

    def __init__(self, builder):
        self.builder = builder

    def convert(self, node: ASTNode) -> tuple[int, dict]:
        """
        转换AST节点为Scratch积木
        返回: (block_type, block_id或value)
        """
        if isinstance(node, NumberNode):
            return (1, node.value)  # 直接值

        elif isinstance(node, StringNode):
            return (1, node.value)

        elif isinstance(node, VariableNode):
            # 创建变量引用积木
            block_id = self.builder.generate_id()
            self.builder.current_sprite["blocks"][block_id] = {
                "opcode": "data_variable",
                "next": None,
                "parent": None,
                "inputs": {},
                "fields": {"VARIABLE": [node.name, None]},
                "shadow": True,
                "topLevel": False
            }
            return (2, block_id)  # shadow block

        elif isinstance(node, BinOpNode):
            # 创建运算符积木
            return self._convert_binop(node)

        elif isinstance(node, UnaryOpNode):
            return self._convert_unary(node)

        elif isinstance(node, FunctionNode):
            return self._convert_function(node)

    def _convert_binop(self, node: BinOpNode) -> tuple[int, str]:
        """转换二元运算"""
        # 映射运算符到Scratch opcode
        op_map = {
            '+': 'operator_add',
            '-': 'operator_subtract',
            '*': 'operator_multiply',
            '/': 'operator_divide',
            '%': 'operator_mod',
            '>': 'operator_gt',
            '<': 'operator_lt',
            '=': 'operator_equals',
            '且': 'operator_and',
            '或': 'operator_or',
        }

        opcode = op_map.get(node.op)
        if not opcode:
            raise ValueError(f"不支持的运算符: {node.op}")

        # 递归转换左右子树
        left_type, left_value = self.convert(node.left)
        right_type, right_value = self.convert(node.right)

        # 创建运算符积木
        block_id = self.builder.generate_id()
        self.builder.current_sprite["blocks"][block_id] = {
            "opcode": opcode,
            "next": None,
            "parent": None,
            "inputs": {
                "NUM1": [left_type, left_value],
                "NUM2": [right_type, right_value]
            },
            "fields": {},
            "shadow": False,
            "topLevel": False
        }

        return (2, block_id)
```

---

### 2.5 第五层：集成到Parser

**文件：** `compiler/parser.py`（修改）

```python
from .lexer import Lexer
from .expression_parser import ExpressionParser
from .ast_to_scratch import ASTToScratch

class ScratchLangParser:
    def __init__(self):
        # ... 现有代码 ...
        self.ast_converter = ASTToScratch(self.builder)

    def _parse_value(self, text):
        """解析值（改进版）"""
        text = text.strip()

        # 简单值：直接返回
        if self._is_simple_value(text):
            return self._parse_simple_value(text)

        # 复杂表达式：使用新解析器
        try:
            # 1. 分词
            lexer = Lexer(text)
            tokens = lexer.tokenize()

            # 2. 解析为AST
            parser = ExpressionParser(tokens)
            ast = parser.parse()

            # 3. 转换为Scratch JSON
            block_type, block_value = self.ast_converter.convert(ast)
            return [block_type, block_value]

        except Exception as e:
            # 降级到旧逻辑
            return self._parse_simple_value(text)

    def _is_simple_value(self, text):
        """判断是否为简单值"""
        # 纯数字
        if text.replace('.', '').replace('-', '').isdigit():
            return True
        # 纯字符串
        if text.startswith('"') and text.endswith('"'):
            return True
        # 单个变量引用
        if text.startswith('~') and ' ' not in text:
            return True
        # 没有运算符
        if not any(op in text for op in ['+', '-', '*', '/', '>', '<', '且', '或']):
            return True
        return False
```

---

## 三、权力边界划分

### 正则管什么？
- ✅ 匹配积木结构：`当绿旗被点击`, `如果...那么`, `重复...次`
- ✅ 提取参数位置：`移动 (.*) 步` → 提取中间的表达式
- ✅ 识别变量声明：`变量: 分数 = 0`

### 表达式解析器管什么？
- ✅ 所有包含运算符的表达式
- ✅ 所有包含括号的表达式
- ✅ 所有函数调用

### 明确的交接点

```python
# parser.py 中
match = re.match(r"移动\s+(.+)\s*步", line)
if match:
    expr_text = match.group(1)  # 提取 "10 + 5"

    # 交给表达式解析器
    expr_value = self._parse_value(expr_text)

    # 拿回结果，填入积木
    block["inputs"]["STEPS"] = expr_value
```

---

## 四、单元测试策略

### 4.1 Lexer测试

```python
# tests/test_lexer.py
def test_lexer_basic():
    lexer = Lexer("1 + 2")
    tokens = lexer.tokenize()
    assert tokens[0].type == TokenType.NUMBER
    assert tokens[1].type == TokenType.OPERATOR
    assert tokens[2].type == TokenType.NUMBER

def test_lexer_complex():
    lexer = Lexer("(~a + 1) * 2")
    tokens = lexer.tokenize()
    assert len(tokens) == 8  # ( ~ a + 1 ) * 2 EOF
```

### 4.2 ExpressionParser测试

```python
# tests/test_expression_parser.py
def test_parse_arithmetic():
    tokens = Lexer("1 + 2 * 3").tokenize()
    ast = ExpressionParser(tokens).parse()
    # 验证AST结构
    assert isinstance(ast, BinOpNode)
    assert ast.op == '+'
    assert isinstance(ast.right, BinOpNode)
    assert ast.right.op == '*'

def test_parse_priority():
    tokens = Lexer("1 或 2 且 3").tokenize()
    ast = ExpressionParser(tokens).parse()
    # 验证 且 优先级高于 或
    assert ast.op == '或'
    assert ast.right.op == '且'
```

### 4.3 集成测试

```python
# tests/test_expression_integration.py
def test_full_pipeline():
    parser = ScratchLangParser()
    result = parser._parse_value("(1 + 2) * 3")
    # 验证生成的Scratch积木结构
    assert result[0] == 2  # block type
    block_id = result[1]
    block = parser.builder.current_sprite["blocks"][block_id]
    assert block["opcode"] == "operator_multiply"
```

---

## 五、实施步骤

### Week 1: 基础设施
- Day 1: 实现Lexer + 测试（20个用例）
- Day 2: 实现AST Node定义
- Day 3: 实现ExpressionParser（算术运算）+ 测试（30个用例）
- Day 4: 实现ASTToScratch + 测试（20个用例）
- Day 5: 集成到parser.py + 测试（10个用例）

### Week 2: 完善功能
- Day 1: 添加逻辑运算支持
- Day 2: 添加函数调用支持
- Day 3: 错误提示优化
- Day 4: 性能优化
- Day 5: 文档和示例

---

## 六、防屎山检查清单

### ✅ 解耦检查
- [ ] Lexer不依赖Parser
- [ ] ExpressionParser不依赖Builder
- [ ] ASTToScratch只依赖Builder接口
- [ ] 每个模块可独立测试

### ✅ 边界检查
- [ ] 正则只匹配结构，不解析表达式
- [ ] 表达式解析器不处理积木结构
- [ ] 没有全局变量污染

### ✅ 测试覆盖
- [ ] Lexer测试覆盖率 > 90%
- [ ] ExpressionParser测试覆盖率 > 90%
- [ ] 集成测试覆盖所有运算符

### ✅ 可维护性
- [ ] 每个函数 < 50行
- [ ] 每个类 < 300行
- [ ] 有清晰的注释和文档

---

## 七、总结

这个方案的核心优势：

1. **分层清晰**：每一层都是黑盒，可独立开发和测试
2. **易于扩展**：要支持新运算符？只需修改Lexer和ExpressionParser
3. **可复用**：如果未来换成Lark，只需替换Lexer和ExpressionParser，ASTToScratch可以保留
4. **防屎山**：严格的边界和充分的测试

**这不是"打补丁"，这是"优雅的渐进式改进"。**
